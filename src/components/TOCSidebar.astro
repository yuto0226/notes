---
import { ScrollArea } from '@/components/ui/scroll-area'
import type { TOCSection } from '@/lib/data-utils'
import { getParentId, isSubpost } from '@/lib/data-utils'
import { cn, getHeadingMargin } from '@/lib/utils'
import type { HeadingNode, TOCStyleConfig } from '@/types.ts'
import { Icon } from 'astro-icon/components'
import TOCItem from './TOCItem.astro'

type Props = {
  sections: TOCSection[]
  currentPostId: string
}

const { sections, currentPostId } = Astro.props
const isCurrentSubpost = isSubpost(currentPostId)
const parentId = isCurrentSubpost ? getParentId(currentPostId) : currentPostId

function buildHeadingTree(headings: any[]): HeadingNode[] {
  const roots: HeadingNode[] = []
  const stack: HeadingNode[] = []

  headings.forEach((heading) => {
    const node: HeadingNode = {
      slug: heading.slug,
      text: heading.text,
      depth: heading.depth,
      children: [],
    }

    while (stack.length > 0 && stack[stack.length - 1].depth >= node.depth) {
      stack.pop()
    }

    if (stack.length === 0) {
      roots.push(node)
    } else {
      stack[stack.length - 1].children.push(node)
    }

    stack.push(node)
  })

  return roots
}

const TOC_STYLE: TOCStyleConfig = {
  text: 'text-sm',
  link: 'text-foreground/60',
  linkDisabled: 'text-foreground/40',
  border: 'border-border/40',
  dot: 'bg-foreground/40',
}
---

{
  sections.length > 0 && (
    <div
      id="toc-sidebar-container"
      class="sticky top-20 col-start-1 row-span-1 mr-8 ml-auto hidden h-[calc(100vh-5rem)] max-w-md xl:block"
    >
      <ScrollArea
        client:load
        className="flex max-h-[calc(100vh-8rem)] flex-col overflow-y-auto"
        type="hover"
        data-toc-scroll-area
      >
        <div class="flex flex-col gap-2 px-4">
          <span class="flex items-center gap-2 text-lg font-medium">
            <Icon name="lucide:list" class="size-4" />
            Table of Contents
          </span>
          {sections.map((section, index) => {
            const isFirstSubpost =
              section.type === 'subpost' &&
              (index === 0 || sections[index - 1].type === 'parent')

            return (
              <>
                {isFirstSubpost && (
                  <div class="mt-2 flex items-center gap-2">
                    <div class="bg-border h-px flex-1" />
                    <span class="text-muted-foreground text-xs font-medium">
                      Subposts
                    </span>
                    <div class="bg-border h-px flex-1" />
                  </div>
                )}

                {section.type === 'parent' ? (
                  <nav class="toc-nav">
                    {buildHeadingTree(section.headings).map((node) => (
                      <TOCItem
                        node={node}
                        style={TOC_STYLE}
                        isCurrentSubpost={isCurrentSubpost}
                        parentId={parentId}
                      />
                    ))}
                  </nav>
                ) : (
                  <div
                    class={cn(
                      'rounded-md border p-2',
                      section.subpostId === currentPostId ? 'bg-muted/50' : '',
                    )}
                  >
                    <ul class="flex list-none flex-col gap-y-2">
                      <li
                        class={cn(
                          'text-xs font-medium',
                          section.subpostId === currentPostId
                            ? 'text-foreground'
                            : 'text-foreground/60',
                        )}
                      >
                        <a
                          href={
                            section.subpostId === currentPostId
                              ? '#'
                              : `/blog/${section.subpostId}`
                          }
                          class="marker:text-foreground/30 list-none underline decoration-transparent underline-offset-[3px] transition-colors duration-200 hover:decoration-inherit"
                          data-heading-link={
                            section.subpostId === currentPostId
                              ? 'top'
                              : `${section.subpostId}-top`
                          }
                        >
                          {section.title}
                        </a>
                      </li>
                      {section.headings.map((heading) => (
                        <li
                          class={cn(
                            'text-xs',
                            getHeadingMargin(heading.depth),
                            section.subpostId === currentPostId
                              ? 'text-foreground/60'
                              : 'text-foreground/30',
                          )}
                        >
                          <a
                            href={
                              section.subpostId === currentPostId
                                ? `#${heading.slug}`
                                : `/blog/${section.subpostId}#${heading.slug}`
                            }
                            class="marker:text-foreground/30 hover:text-foreground/60 list-none underline decoration-transparent underline-offset-[3px] transition-colors duration-200 hover:decoration-inherit"
                            data-heading-link={
                              section.subpostId === currentPostId
                                ? heading.slug
                                : `${section.subpostId}-${heading.slug}`
                            }
                          >
                            {heading.text}
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </>
            )
          })}
        </div>
      </ScrollArea>
    </div>
  )
}

<script>
  const HEADER_OFFSET = 150

  class TOCState {
    links: NodeListOf<Element> = document.querySelectorAll(
      '[data-heading-link]',
    )
    activeIds: string[] = []
    headings: HTMLElement[] = []
    regions: { id: string; start: number; end: number }[] = []
    scrollArea: HTMLElement | null = null
    tocScrollArea: HTMLElement | null = null
    expandedSections = new Set<string>()
    hoverExpandedSections = new Set<string>()
    hoverTimeouts = new Map<string, number>()

    reset() {
      this.links = document.querySelectorAll(
        '#toc-sidebar-container [data-heading-link]',
      )
      this.activeIds = []
      this.headings = []
      this.regions = []
      this.expandedSections.clear()
      this.hoverExpandedSections.clear()
      this.hoverTimeouts.clear()
      const tocContainer = document.getElementById('toc-sidebar-container')
      this.scrollArea =
        tocContainer?.querySelector('[data-radix-scroll-area-viewport]') || null
      this.tocScrollArea =
        tocContainer?.querySelector('[data-toc-scroll-area]') || null
    }
  }

  const state = new TOCState()

  class HeadingRegions {
    static build() {
      state.headings = Array.from(
        document.querySelectorAll<HTMLElement>(
          '.prose h2, .prose h3, .prose h4, .prose h5, .prose h6',
        ),
      )

      if (state.headings.length === 0) {
        state.regions = []
        return
      }

      state.regions = state.headings.map((heading, index) => {
        const nextHeading = state.headings[index + 1]
        return {
          id: heading.id,
          start: heading.offsetTop,
          end: nextHeading ? nextHeading.offsetTop : document.body.scrollHeight,
        }
      })
    }

    static getVisibleIds(): string[] {
      if (state.headings.length === 0) return []

      const viewportTop = window.scrollY + HEADER_OFFSET

      let activeHeading: HTMLElement | null = null
      let closestDistance = Infinity

      state.headings.forEach((heading) => {
        const headingTop = heading.offsetTop

        // 如果 heading 在視窗頂部以上或剛好在頂部
        if (headingTop <= viewportTop) {
          const distance = viewportTop - headingTop
          if (distance < closestDistance) {
            closestDistance = distance
            activeHeading = heading
          }
        }
      })

      if (!activeHeading && state.headings.length > 0) {
        activeHeading = state.headings[0]
      }

      return activeHeading ? [activeHeading.id] : []
    }
  }

  class TOCExpander {
    static expand(slug: string, isHover: boolean = false) {
      const children = document.querySelector(
        `[data-children="${slug}"]`,
      ) as HTMLElement
      if (!children) return

      children.style.gridTemplateRows = '1fr'
      children.style.opacity = '1'
      state.expandedSections.add(slug)

      if (isHover) {
        state.hoverExpandedSections.add(slug)
      }
    }

    static collapse(slug: string) {
      const children = document.querySelector(
        `[data-children="${slug}"]`,
      ) as HTMLElement
      if (!children) return

      children.style.gridTemplateRows = '0fr'
      children.style.opacity = '0'
      state.expandedSections.delete(slug)
      state.hoverExpandedSections.delete(slug)
    }

    static updateBasedOnScroll() {
      // 先收起所有不是 hover 展開且不應該保持展開的項目
      const allExpanded = Array.from(state.expandedSections)
      allExpanded.forEach((slug) => {
        // 如果不是 hover 展開的，且不應該保持展開，就收起
        if (
          !state.hoverExpandedSections.has(slug) &&
          !this.shouldStayExpanded(slug)
        ) {
          this.collapse(slug)
        }
      })

      // 再展開所有 active 項目及其父級
      state.activeIds.forEach((id) => {
        const item = document.querySelector(`[data-slug="${id}"]`)
        if (!item) return

        // 展開所有父級
        let current: Element | null = item
        while (current) {
          const parent = current.getAttribute('data-parent')
          if (parent && !state.expandedSections.has(parent)) {
            this.expand(parent, false)
          }
          current = parent
            ? document.querySelector(`[data-slug="${parent}"]`)
            : null
        }

        // 只展開有子元素的當前項
        const hasChildren = document.querySelector(`[data-children="${id}"]`)
        if (hasChildren && !state.expandedSections.has(id)) {
          this.expand(id, false)
        }
      })

      // 收起那些通過 hover 展開但不應該保持展開的項目
      const hoverExpanded = Array.from(state.hoverExpandedSections)
      hoverExpanded.forEach((slug) => {
        if (!this.shouldStayExpanded(slug)) {
          this.collapse(slug)
        }
      })
    }

    static collapseInvalidHoverItems() {
      // 只收起那些通過 hover 展開但不應該保持展開的項目
      const hoverExpanded = Array.from(state.hoverExpandedSections)
      hoverExpanded.forEach((slug) => {
        if (!this.shouldStayExpanded(slug)) {
          this.collapse(slug)
        }
      })
    }

    static shouldStayExpanded(slug: string): boolean {
      // 檢查是否有子項或後代是 active
      const children = document.querySelectorAll(`[data-parent="${slug}"]`)
      for (const child of children) {
        const childSlug = child.getAttribute('data-slug')
        if (childSlug && state.activeIds.includes(childSlug)) {
          return true
        }
        if (childSlug && this.shouldStayExpanded(childSlug)) {
          return true
        }
      }

      // 檢查自己是否是 active
      if (state.activeIds.includes(slug)) {
        return true
      }

      return false
    }

    static initHoverBehavior() {
      const items = document.querySelectorAll('.toc-item')

      items.forEach((item) => {
        const slug = item.getAttribute('data-slug')
        if (!slug) return

        const hasChildren = document.querySelector(`[data-children="${slug}"]`)
        if (!hasChildren) return

        item.addEventListener('mouseenter', () => {
          if (state.hoverTimeouts.has(slug)) {
            clearTimeout(state.hoverTimeouts.get(slug))
            state.hoverTimeouts.delete(slug)
          }

          const timeout = window.setTimeout(() => {
            if (!state.expandedSections.has(slug)) {
              this.expand(slug, true)
            }
          }, 200)

          state.hoverTimeouts.set(slug, timeout)
        })

        item.addEventListener('mouseleave', () => {
          if (state.hoverTimeouts.has(slug)) {
            clearTimeout(state.hoverTimeouts.get(slug))
            state.hoverTimeouts.delete(slug)
          }

          const timeout = window.setTimeout(() => {
            // 只收起通過 hover 展開的項目
            if (
              state.hoverExpandedSections.has(slug) &&
              !this.shouldStayExpanded(slug)
            ) {
              this.collapse(slug)
            }
          }, 300)

          state.hoverTimeouts.set(slug, timeout)
        })
      })
    }
  }

  class TOCScrollMask {
    static update() {
      if (!state.scrollArea || !state.tocScrollArea) return

      const { scrollTop, scrollHeight, clientHeight } = state.scrollArea
      const threshold = 5
      const isAtTop = scrollTop <= threshold
      const isAtBottom = scrollTop >= scrollHeight - clientHeight - threshold

      state.tocScrollArea.classList.toggle('mask-t-from-90%', !isAtTop)
      state.tocScrollArea.classList.toggle('mask-b-from-90%', !isAtBottom)
    }
  }

  class TOCLinks {
    static update(headingIds: string[]) {
      state.links.forEach((link) => {
        link.classList.remove('text-primary', 'font-semibold')

        const dot = link.parentElement?.querySelector('[data-dot]')
        if (dot) {
          dot.classList.remove('h-1.5', 'w-1.5', '!bg-primary', 'drop-shadow')
          dot.classList.add('h-1', 'w-1')
        }
      })

      headingIds.forEach((id) => {
        if (id) {
          const activeLink = document.querySelector(
            `#toc-sidebar-container [data-heading-link="${id}"]`,
          )
          if (activeLink) {
            activeLink.classList.add('text-primary', 'font-semibold')

            const dot = activeLink.parentElement?.querySelector('[data-dot]')
            if (dot) {
              dot.classList.remove('h-1', 'w-1')
              dot.classList.add('h-1.5', 'w-1.5', '!bg-primary', 'drop-shadow')
            }
          }
        }
      })

      // 更新展開狀態
      TOCExpander.updateBasedOnScroll()

      this.scrollToActive(headingIds)
    }

    static scrollToActive(headingIds: string[]) {
      if (!state.scrollArea || !headingIds.length) return

      const activeLink = document.querySelector(
        `#toc-sidebar-container [data-heading-link="${headingIds[0]}"]`,
      )
      if (!activeLink) return

      const { top: areaTop, height: areaHeight } =
        state.scrollArea.getBoundingClientRect()
      const { top: linkTop, height: linkHeight } =
        activeLink.getBoundingClientRect()

      const currentLinkTop = linkTop - areaTop + state.scrollArea.scrollTop
      const targetScroll = Math.max(
        0,
        Math.min(
          currentLinkTop - (areaHeight - linkHeight) / 2,
          state.scrollArea.scrollHeight - state.scrollArea.clientHeight,
        ),
      )

      if (Math.abs(targetScroll - state.scrollArea.scrollTop) > 5) {
        state.scrollArea.scrollTop = targetScroll
      }
    }
  }

  class TOCController {
    static handleScroll() {
      const newActiveIds = HeadingRegions.getVisibleIds()
      const idsChanged =
        JSON.stringify(newActiveIds) !== JSON.stringify(state.activeIds)

      if (idsChanged) {
        state.activeIds = newActiveIds
        TOCLinks.update(state.activeIds)
      }

      // 總是檢查是否有 hover 項目需要收起
      if (!idsChanged && state.hoverExpandedSections.size > 0) {
        TOCExpander.collapseInvalidHoverItems()
      }
    }

    static handleTOCScroll = () => TOCScrollMask.update()

    static handleResize() {
      HeadingRegions.build()
      const newActiveIds = HeadingRegions.getVisibleIds()

      if (JSON.stringify(newActiveIds) !== JSON.stringify(state.activeIds)) {
        state.activeIds = newActiveIds
        TOCLinks.update(state.activeIds)
      }

      TOCScrollMask.update()
    }

    static init() {
      state.reset()
      HeadingRegions.build()

      if (state.headings.length === 0) {
        TOCLinks.update([])
        return
      }

      this.handleScroll()
      setTimeout(TOCScrollMask.update, 100)

      TOCExpander.initHoverBehavior()

      const options = { passive: true }
      window.addEventListener('scroll', this.handleScroll, options)
      window.addEventListener('resize', this.handleResize, options)
      state.scrollArea?.addEventListener(
        'scroll',
        this.handleTOCScroll,
        options,
      )
    }

    static cleanup() {
      window.removeEventListener('scroll', this.handleScroll)
      window.removeEventListener('resize', this.handleResize)
      state.scrollArea?.removeEventListener('scroll', this.handleTOCScroll)

      state.hoverTimeouts.forEach((timeout) => clearTimeout(timeout))

      Object.assign(state, {
        activeIds: [],
        headings: [],
        regions: [],
        scrollArea: null,
        tocScrollArea: null,
        expandedSections: new Set(),
        hoverExpandedSections: new Set(),
        hoverTimeouts: new Map(),
      })
    }
  }

  document.addEventListener('astro:page-load', () => TOCController.init())
  document.addEventListener('astro:after-swap', () => {
    TOCController.cleanup()
    TOCController.init()
  })
  document.addEventListener('astro:before-swap', () => TOCController.cleanup())
</script>
